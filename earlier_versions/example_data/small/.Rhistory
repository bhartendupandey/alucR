}
#####
## adjust demand file
# 1. add natural demand
# 2. adjust for spatial restrictions (based on sp.rest_index)
# 3. combine natural and adjusted demand
nochange.n <- if (length(no.change) > 0 ){
sum (lc_pix[no.change ])
}else {c(0)}
natural.d <- lc_n - nochange.n - sum(demand[epoche,])
#
lc.sp.rest <- tabulate(data_vector[sp.rest_index], nbins=max(lc_unique))
demand.adj <- demand[epoche,] - lc.sp.rest [sort(lu_suit)]
natural.adj <- natural.d - sum(lc.sp.rest[natural])
if (sign(natural.adj)== -1){print("land use cannot be allocated")}
#
demand.new <- cbind(demand.adj, natural.adj)
#####
# 1. how long is the current land use/cover already there? define for the first epoche. The next are updated during modelling steps
# 2. set previous year land cover vector (copy data vectore) ## neccesary?
if (epoche==1){
trans.years_vector <-  if(class(init.years)=="RasterLayer"){
getValues (init.years)
} else {
rep(init.years, length (data_vector))
}
tprop.previous_vector <- data_vector
}
#####
# transition years (a little complex)
# general:
# transitions which are not allowed are set to NA in the respective suitability layer (target)
# transitions different to 1, referring to transition possible after one iteration (year) are identified
# those identified are checked against the transition years vector. if years < transition years the target suitability is set to NA
# specific steps:
# first edit trajectory matrix
if (length(traj[traj==0 | is.na(traj)] )>0){
# for not allowed changes (100 years more than modelling years)
traj[traj==0 | is.na (traj)] <- nrow(demand)+ 100
}
# conversion restrictions from all land covers to the  land use classes (suitability layer)
# for all unique land cover classes to land use classes
for (i in 1:length(lc_unique)){
# identify classes with restricted trajectories to land use
traj_ind <- which (traj[lc_unique[i],lu_suit] != 1)
# in case no restriction due to trajectories apply
if (length(traj_ind) > 0){
# index classes with restricted trajectories
cat_index <- which(tprop.previous_vector==lc_unique[i])
for (a in 1:length(traj_ind)){
# set p_vector at the specific location for the specific layer  to NA if the amount of years is not reached
p_vector[cat_index, traj_ind[a]]<- ifelse (trans.years_vector[cat_index] < traj[lc_unique[i], lu_suit[a]], NA, p_vector[cat_index, traj_ind[a]])
cat(i)
}}
}
# conversion restrictions from all land covers to natural vegetation class
for (i in 1:length(lc_unique)){
traj_ind <- which(is.element (1 ,  traj[lc_unique[i],natural])==FALSE) # identify which trajectories are unequal 1 (are not allowed after one year)
if (length(traj_ind) > 0){
cat_index <- which(tprop.previous_vector==lc_unique[i])
p.natural[cat_index] <- ifelse (trans.years_vector[cat_index] < min(traj[lc_unique[i], natural]), NA, p.natural[cat_index])
cat(i)
#print(trans.years_vector[cat_index] < min(traj[lc_unique[i], natural]))
}}
########
########
# add ELAS
for (i in 1:length(lu_suit)) {
elas_index <- which(data_vector==lu_suit[i])
p_vector[elas_index,i] <- p_vector[elas_index, i] + as.numeric(elas[lu_suit[i]])
}
# add ELAS on natural vegetation layer
for (i in 1: length (natural)){
elas_index <- which(data_vector== natural[i])
p.natural[elas_index] <- p.natural[elas_index] + as.numeric(elas[natural[i]])
}
#########
# combine p vector with natural vegetation vector
p_vector.N <- cbind( p_vector, p.natural)
#####
# set initial values for ITER
iter <- rep(0,ncol(p_vector.N))
#########
#prepare log data frames
# persistent through epoches
if (epoche==1){
log1 <- c()
log2 <- c()
names.log <- c("u", paste("pix.diff_lc",lu_suit.N, sep=""), paste("korr_lc",lu_suit.N, sep=""), paste("iter_lc",lc_suit.N, sep=""))
}
iter.hist <- c(iter)
diff.pix.hist <- c()
diff.p.hist <- c()
change.p.hist <- c()
korr.hist <- c()
print (paste("start iteration for epoche:", epoche, sep=""))
u <- 1
# multicore definition
cl <- makeCluster(getOption("cl.cores", ncores));
if (u==1){
lc_suit.N <- ncol(p_vector.N) # layers of suitability including natural veg. for later use
p2_vector <- p_vector.N
}else{
for (i in c(1:layer)) {
p2_vector[,i] <- p_vector[,i]+as.numeric(iter[lc_suit.N[i]]);
}
}
####
# find winner
# if all layer have NA, dann NA, sonst which.max(P2)
tprop_vector <- lu.N[parRapply(cl,p2_vector,FUN=function(w) ifelse(all(is.na(w)),NA,which.max(w)))]
#
# evaluate result
n <- tabulate(tprop_vector,nbins=max(lu.N))[sort(lu.N)]
#
diff.pix <- n - demand.new
diff.perc <- diff.pix/demand.new
#save history
diff.pix.hist <- rbind(diff.pix.hist, diff.pix)
diff.p.hist <- rbind(diff.p.hist, diff.perc)
#adjust iter based on difference from demand
if(u==1){ # initializing Korr
korr= -1*sign(diff.perc)*1/100
}else{ # modifying Korr based on prior results
change.perc <- abs((diff.pix.hist[u-1,]-diff.pix.hist[u,])/(diff.pix.hist[u-1,])*100)
proportion <- abs(diff.pix.hist[u,])/ colSums(abs(diff.pix.hist[c(u,u-1),]),na.rm=TRUE)
better<- abs(diff.pix.hist[u,])< abs(diff.pix.hist[u-1,])
korr <- as.vector(ifelse(diff.pix.hist[u,]== 0 , 0,
ifelse(diff.pix.hist[u,]!=0 & korr.hist[u-1,]==0,-1*sign(diff.perc)*1/sample(50:150, 1),
ifelse(better==FALSE & sign(diff.pix.hist[u,])==sign(diff.pix.hist[u-1,]), korr.hist[u-1,]*2,
ifelse(abs(diff.perc)<= 0.001 & abs(diff.pix.hist[u,])<= 20 & sign(diff.pix.hist[u,])==sign(diff.pix.hist[u-1,]), (korr.hist[u-1,]/2)+(korr.hist[u-1,]/2)*proportion,
ifelse(change.perc< 20& sign(diff.perc)==sign(diff.p.hist[u-1,]),korr.hist[u-1,]*2,
ifelse(change.perc< 40& change.perc >= 20 & sign(diff.perc)==sign(diff.p.hist[u-1,]), korr.hist[u-1,]+(korr.hist[u-1,]*proportion),
ifelse(sign(diff.pix.hist[u,])  !=sign(diff.pix.hist[u-1,]), -1* korr.hist[u-1,]*proportion,
korr.hist[u-1,]))))))), mode="numeric")
change.p.hist <- rbind(change.p.hist, change.perc)
}
iter <- iter + korr ;
diff.pix
n
demand.new
as.vector(demand.new)
c(demand.new)
cbind(demand.new)
vector(demand.new)
as.vector(demand.new)
numeric(demand.new)
as.numeric(demand.new)
n
class(n)
as.integer(demand.new)
as.integer(n)
as.integer(demand.new)
source('~/.active-rstudio-document')
scenarios <- aluc(lc=lc, suit=suit, spatial=spatial,demand=as.matrix(demand), elas=as.matrix(elas), traj=as.matrix(traj), nochange.lc=nochange.lc, init.years=5, ncores=detectCores()/2,iter.max=100, writeRaster=FALSE)
# The land use/cover data is a reclassified TerraClass product of INPE http://www.inpe.br/cra/projetos_pesquisas/terraclass2010.php
#example script:
#set workingdirectory
setwd("C:/Users/geo_flgo/Documents/GitHub/alucR/example_data/small")
#load packages
library(rgdal)
library(sp)
library(raster)
library(parallel)
#load raster
lc<- raster("tc08_aggregated.tif" )
suit<- stack("suitability_stack.tif"); names(suit)<- c("lc1","lc2","lc3","lc4","lc7","lc8")
suit_lu <- subset(suit, subset=c("lc3", "lc4", "lc7"))
spatial<- raster("PAall_aggregated.tif")
#load csv
demand<- read.csv("demand_aggregated.csv", row.names=1)
demand_lu <- demand[,c(3,4,7)] # land use demand pasture, crop, urban
names(demand_lu)<- c("lc3", "lc4", "lc7")
nochange.lc <- c("lc5","lc6","lc8") # müssen ausmaskiert werden und später wieder eingesetzt
natural.lc <- c("lc1","lc2")
elas<- read.csv("elas.csv",row.names=1)
traj <- read.csv("trajectories.csv",row.names=1)
init.years=5
ncores=detectCores()/2
suit  <- subset (suit_lu, subset=c(3,2,1))
demand <- demand_lu
scenarios <- aluc(lc=lc, suit=suit, spatial=spatial,demand=as.matrix(demand), elas=as.matrix(elas), traj=as.matrix(traj), nochange.lc=nochange.lc, init.years=5, ncores=detectCores()/2,iter.max=100, writeRaster=FALSE)
source('~/.active-rstudio-document')
scenarios <- aluc(lc=lc, suit=suit, spatial=spatial,demand=as.matrix(demand), elas=as.matrix(elas), traj=as.matrix(traj), nochange.lc=nochange.lc, init.years=5, ncores=detectCores()/2,iter.max=100, writeRaster=FALSE)
source('~/.active-rstudio-document')
scenarios <- aluc(lc=lc, suit=suit, spatial=spatial,demand=as.matrix(demand), elas=as.matrix(elas), traj=as.matrix(traj), nochange.lc=nochange.lc, init.years=5, ncores=detectCores()/2,iter.max=100, writeRaster=FALSE)
data_vector <- if (epoche==1) {
getValues(lc)
}else {
tprop_previous_vector # getValues (new.data) # change to "tprop_previous_vector" or "tprop_vector" no need to read raster values, since they are stored already
}
p_vector <-   if(class(suit)=="RasterStack" | class(suit)=="RasterBrick"){
getValues(suit) # if only one stack is specified
}else if (class(suit)=="character"){
getValues(get(suit[epoche])) # in case different stacks for each episode are specified - possibly usefull if  for example new roads are build
}
sp.rest_vector <- if(class(spatial)=="RasterLayer"){
getValues(spatial) # spatial restrictions
}else if (class(spatial)=="character"){
getValues(get(spatial[epoche])) # in case different stacks for each episode are specified - possibly useful if the protected area network will be expanded during the modelling experiment
}
print("EPOCHE:",epoche, sep=" ")
#raster to vector
data_vector <- if (epoche==1) {
getValues(lc)
}else {
tprop_previous_vector # getValues (new.data) # change to "tprop_previous_vector" or "tprop_vector" no need to read raster values, since they are stored already
}
p_vector <-   if(class(suit)=="RasterStack" | class(suit)=="RasterBrick"){
getValues(suit) # if only one stack is specified
}else if (class(suit)=="character"){
getValues(get(suit[epoche])) # in case different stacks for each episode are specified - possibly usefull if  for example new roads are build
}
sp.rest_vector <- if(class(spatial)=="RasterLayer"){
getValues(spatial) # spatial restrictions
}else if (class(spatial)=="character"){
getValues(get(spatial[epoche])) # in case different stacks for each episode are specified - possibly useful if the protected area network will be expanded during the modelling experiment
}
#land use classes to be modelled
lu_suit <- as.numeric(gsub("lc","",colnames(p_vector)))   # tolower(colnames(p_vector))
#no change classes
no.change <- as.numeric(gsub("lc","",nochange.lc))
#natural land cover classes (as numeric)
natural <- as.numeric(gsub("lc","",natural.lc))
# same as length (lu_suit) number of suitability layers to be modeled
#lu_suit_l <- ncol(p_vector)
# pixel for all land use/cover classes
lc_pix <- tabulate(data_vector, nbins=max(data_vector))
# total amount of pixels (excl. NAs)
lc_n <- sum(lc_pix)
# unique classes land use/cover classes
lc_unique <- sort(unique(data_vector))
#?	# +1 pseudo natural layer for iteration algorithm
pseudo.N <- max(lu_suit)+1
lu.N <- c(lu_suit,  pseudo.N)
lc_suit.N <- length(lu.N)
epoche=1
print("EPOCHE:",epoche, sep=" ")
#raster to vector
data_vector <- if (epoche==1) {
getValues(lc)
}else {
tprop_previous_vector # getValues (new.data) # change to "tprop_previous_vector" or "tprop_vector" no need to read raster values, since they are stored already
}
p_vector <-   if(class(suit)=="RasterStack" | class(suit)=="RasterBrick"){
getValues(suit) # if only one stack is specified
}else if (class(suit)=="character"){
getValues(get(suit[epoche])) # in case different stacks for each episode are specified - possibly usefull if  for example new roads are build
}
sp.rest_vector <- if(class(spatial)=="RasterLayer"){
getValues(spatial) # spatial restrictions
}else if (class(spatial)=="character"){
getValues(get(spatial[epoche])) # in case different stacks for each episode are specified - possibly useful if the protected area network will be expanded during the modelling experiment
}
lu_suit <- as.numeric(gsub("lc","",colnames(p_vector)))   # tolower(colnames(p_vector))
#no change classes
no.change <- as.numeric(gsub("lc","",nochange.lc))
#natural land cover classes (as numeric)
natural <- as.numeric(gsub("lc","",natural.lc))
# same as length (lu_suit) number of suitability layers to be modeled
#lu_suit_l <- ncol(p_vector)
# pixel for all land use/cover classes
lc_pix <- tabulate(data_vector, nbins=max(data_vector))
# total amount of pixels (excl. NAs)
lc_n <- sum(lc_pix)
# unique classes land use/cover classes
lc_unique <- sort(unique(data_vector))
#?	# +1 pseudo natural layer for iteration algorithm
pseudo.N <- max(lu_suit)+1
lu.N <- c(lu_suit,  pseudo.N)
lc_suit.N <- length(lu.N)
#####
# natural vegetation vector
p.natural<- rep(0.5, times=length(data_vector))
# mask NAs from p_vector
if (all(complete.cases(data_vector))==FALSE){ # skip in case no NAs exits
p_vector[is.na(data_vector), ] <- NA
p.natural[is.na(data_vector)]  <- NA
}
#mask no change classes from p_vector
if (length(no.change) > 0 ){
nochange_index <- is.element(data_vector, no.change)
p_vector[nochange_index, ] <- NA
p.natural[nochange_index]  <- NA
}
# mask spatial restrictions from p_vector
if (length(sp.rest_vector) > 0 ){
sp.rest_index <- which(!is.na(sp.rest_vector));
p_vector[sp.rest_index,] <- NA;
p.natural [sp.rest_index] <- NA
}
#####
## adjust demand file
# 1. add natural demand
# 2. adjust for spatial restrictions (based on sp.rest_index)
# 3. combine natural and adjusted demand
nochange.n <- if (length(no.change) > 0 ){
sum (lc_pix[no.change ])
}else {c(0)}
natural.d <- lc_n - nochange.n - sum(demand[epoche,])
#
lc.sp.rest <- tabulate(data_vector[sp.rest_index], nbins=max(lc_unique))
demand.adj <- demand[epoche,] - lc.sp.rest [sort(lu_suit)]
natural.adj <- natural.d - sum(lc.sp.rest[natural])
if (sign(natural.adj)== -1){print("land use cannot be allocated")}
#
demand.new <- cbind(demand.adj, natural.adj)
#####
# 1. how long is the current land use/cover already there? define for the first epoche. The next are updated during modelling steps
# 2. set previous year land cover vector (copy data vectore) ## neccesary?
if (epoche==1){
trans.years_vector <-  if(class(init.years)=="RasterLayer"){
getValues (init.years)
} else {
rep(init.years, length (data_vector))
}
tprop.previous_vector <- data_vector
}
#####
# transition years (a little complex)
# general:
# transitions which are not allowed are set to NA in the respective suitability layer (target)
# transitions different to 1, referring to transition possible after one iteration (year) are identified
# those identified are checked against the transition years vector. if years < transition years the target suitability is set to NA
# specific steps:
# first edit trajectory matrix
if (length(traj[traj==0 | is.na(traj)] )>0){
# for not allowed changes (100 years more than modelling years)
traj[traj==0 | is.na (traj)] <- nrow(demand)+ 100
}
# conversion restrictions from all land covers to the  land use classes (suitability layer)
# for all unique land cover classes to land use classes
for (i in 1:length(lc_unique)){
# identify classes with restricted trajectories to land use
traj_ind <- which (traj[lc_unique[i],lu_suit] != 1)
# in case no restriction due to trajectories apply
if (length(traj_ind) > 0){
# index classes with restricted trajectories
cat_index <- which(tprop.previous_vector==lc_unique[i])
for (a in 1:length(traj_ind)){
# set p_vector at the specific location for the specific layer  to NA if the amount of years is not reached
p_vector[cat_index, traj_ind[a]]<- ifelse (trans.years_vector[cat_index] < traj[lc_unique[i], lu_suit[a]], NA, p_vector[cat_index, traj_ind[a]])
cat(i)
}}
}
# conversion restrictions from all land covers to natural vegetation class
for (i in 1:length(lc_unique)){
traj_ind <- which(is.element (1 ,  traj[lc_unique[i],natural])==FALSE) # identify which trajectories are unequal 1 (are not allowed after one year)
if (length(traj_ind) > 0){
cat_index <- which(tprop.previous_vector==lc_unique[i])
p.natural[cat_index] <- ifelse (trans.years_vector[cat_index] < min(traj[lc_unique[i], natural]), NA, p.natural[cat_index])
cat(i)
#print(trans.years_vector[cat_index] < min(traj[lc_unique[i], natural]))
}}
########
# p_vector normalization skipped
########
# add ELAS
for (i in 1:length(lu_suit)) {
elas_index <- which(data_vector==lu_suit[i])
p_vector[elas_index,i] <- p_vector[elas_index, i] + as.numeric(elas[lu_suit[i]])
}
# add ELAS on natural vegetation layer
for (i in 1: length (natural)){
elas_index <- which(data_vector== natural[i])
p.natural[elas_index] <- p.natural[elas_index] + as.numeric(elas[natural[i]])
}
#########
# combine p vector with natural vegetation vector
p_vector.N <- cbind( p_vector, p.natural)
#####
# set initial values for ITER
iter <- rep(0,ncol(p_vector.N))
#########
#prepare log data frames
# persistent through epoches
if (epoche==1){
log1 <- c()
log2 <- c()
names.log <- c("u", paste("pix.diff_lc",lc_suit.N, sep=""), paste("korr_lc",lc_suit.N, sep=""), paste("iter_lc",lc_suit.N, sep=""))
}
# temporary overwriten at ech epoche
iter.hist <- c(iter)
diff.pix.hist <- c()
diff.p.hist <- c()
change.p.hist <- c()
korr.hist <- c()
#########
# Iteration module
print (paste("start iteration for epoche:", epoche, sep=""))
# initialize iterarion count
u <- 1
# multicore definition
cl <- makeCluster(getOption("cl.cores", ncores));
# start iteration
if (u==1){
lc_suit.N <- ncol(p_vector.N) # layers of suitability including natural veg. for later use
p2_vector <- p_vector.N
}else{
for (i in c(1:layer)) {
p2_vector[,i] <- p_vector[,i]+as.numeric(iter[lc_suit.N[i]]);
}
}
####
# find winner
# if all layer have NA, dann NA, sonst which.max(P2)
tprop_vector <- lu.N[parRapply(cl,p2_vector,FUN=function(w) ifelse(all(is.na(w)),NA,which.max(w)))]
#
# evaluate result
n <- tabulate(tprop_vector,nbins=max(lu.N))[sort(lu.N)]
n
lu.N
sort(lu.N)
diff.pix <- as.integer(n) - as.integer(demand.new)
diff.perc <- diff.pix/demand.new
diff.pix.hist <- rbind(diff.pix.hist, diff.pix)
diff.p.hist <- rbind(diff.p.hist, diff.perc)
#adjust iter based on difference from demand
if(u==1){ # initializing Korr
korr= -1*sign(diff.perc)*1/100
}else{ # modifying Korr based on prior results
change.perc <- abs((diff.pix.hist[u-1,]-diff.pix.hist[u,])/(diff.pix.hist[u-1,])*100)
proportion <- abs(diff.pix.hist[u,])/ colSums(abs(diff.pix.hist[c(u,u-1),]),na.rm=TRUE)
better<- abs(diff.pix.hist[u,])< abs(diff.pix.hist[u-1,])
korr <- as.vector(ifelse(diff.pix.hist[u,]== 0 , 0,
ifelse(diff.pix.hist[u,]!=0 & korr.hist[u-1,]==0,-1*sign(diff.perc)*1/sample(50:150, 1),
ifelse(better==FALSE & sign(diff.pix.hist[u,])==sign(diff.pix.hist[u-1,]), korr.hist[u-1,]*2,
ifelse(abs(diff.perc)<= 0.001 & abs(diff.pix.hist[u,])<= 20 & sign(diff.pix.hist[u,])==sign(diff.pix.hist[u-1,]), (korr.hist[u-1,]/2)+(korr.hist[u-1,]/2)*proportion,
ifelse(change.perc< 20& sign(diff.perc)==sign(diff.p.hist[u-1,]),korr.hist[u-1,]*2,
ifelse(change.perc< 40& change.perc >= 20 & sign(diff.perc)==sign(diff.p.hist[u-1,]), korr.hist[u-1,]+(korr.hist[u-1,]*proportion),
ifelse(sign(diff.pix.hist[u,])  !=sign(diff.pix.hist[u-1,]), -1* korr.hist[u-1,]*proportion,
korr.hist[u-1,]))))))), mode="numeric")
change.p.hist <- rbind(change.p.hist, change.perc)
}
iter <- iter + korr ;
iter <- as.numeric (ifelse(iter <=-1, -1, ifelse(iter>=1,1, iter)))
###
#save history
korr.hist <- rbind(korr.hist, korr)
iter.hist <- rbind(iter.hist, iter)
#####
#   if(plot==TRUE){
#      plot(0,0,xlim = c(2,iter.max),ylim = c(-1.0,1.0),ylab="iter", xlab="iteration", type = "n")
#      legend("topright", legend=paste("LC",lc_cat, sep=""), col=terrain.colors(length(lc_cat)), pch=15)
#      for (i in 1:length(lu.N)){
#        lines(c(1:nrow(iter.hist)),iter.hist[,lc_cat[i]],col=terrain.colors(length(lc_cat))[i],type = 'l', lwd=2);
#      }
#    }
log.tmp <- as.vector(c(u, diff.pix, korr, iter), mode="numeric")
names(log.tmp) <- names.log
log1 <- rbind(log1,log.tmp)
if(print.log==TRUE){
#print(tail(log1))
print(log.tmp [1:(layer+1)])
}
u=u+1;
#stop argument iteration
if (max(abs(diff.perc),na.rm=TRUE) < stop.crit[1] & abs(diff.pix [min.demand]) <= stop.crit[2] )  {
break;
}
if (abs(diff.pix [min.demand]) <= stop.crit[2] & max(abs(diff.pix),na.rm=TRUE)<=stop.crit[3]){
break;
}
stopCluster(cl);
print("allocation done")
log2 <- rbind(log2,log1[nrow(log1),])
#protected areas
tprop_vector[sp.rest_index] <- data_vector[sp.rest_index];
#natural vegetation to pseudo.N code
tprop_vector [is.element(tprop_vector, natural)] <- pseudo.N
#natural vegetation module - reclassify natural vegetation according to transition classes
pseudo.index <- which(is.element(tprop_vector, pseudo.N))
for (i in 1:length(pseudo.index)){
#can before.n be translated to natural
for (a in length(natural):1){
tprop_vector[pseudo.index[i]] <-
ifelse(traj[tprop.previous_vector[pseudo.index[i]], natural[a]] < trans.years_vector[i], natural[a], tprop_vector[pseudo.index[i]])
}}
tprop_vector[nochange_index] <- data_vector[nochange_index]
transition.years_vector <- ifelse(tprop_vector==tprop.previous_vector, trans.years_vector + 1, 1);
new.data <- lc
new.data <- setValues(new.data, tprop_vector)
plot(new.data)
plot(lc)
plot(new.data)
source('~/.active-rstudio-document')
scenarios <- aluc(lc=lc, suit=suit, spatial=spatial,demand=as.matrix(demand), elas=as.matrix(elas), traj=as.matrix(traj), nochange.lc=nochange.lc, init.years=5, ncores=detectCores()/2,iter.max=100, writeRaster=FALSE)
print(n)
source('~/.active-rstudio-document')
scenarios <- aluc(lc=lc, suit=suit, spatial=spatial,demand=as.matrix(demand), elas=as.matrix(elas), traj=as.matrix(traj), nochange.lc=nochange.lc, init.years=5, ncores=detectCores()/2,iter.max=100, writeRaster=FALSE)
print.default
print
source('~/.active-rstudio-document')
scenarios <- aluc(lc=lc, suit=suit, spatial=spatial,demand=as.matrix(demand), elas=as.matrix(elas), traj=as.matrix(traj), nochange.lc=nochange.lc, init.years=5, ncores=detectCores()/2,iter.max=100, writeRaster=FALSE)
source('~/.active-rstudio-document')
scenarios <- aluc(lc=lc, suit=suit, spatial=spatial,demand=as.matrix(demand), elas=as.matrix(elas), traj=as.matrix(traj), nochange.lc=nochange.lc, init.years=5, ncores=detectCores()/2,iter.max=100, writeRaster=FALSE)
suit  <- subset (suit_lu, subset=c(3,2,1))
demand <- demand_lu
scenarios <- aluc(lc=lc, suit=suit, spatial=spatial,demand=as.matrix(demand), elas=as.matrix(elas), traj=as.matrix(traj), nochange.lc=nochange.lc, init.years=5, ncores=detectCores()/2,iter.max=100, writeRaster=FALSE)
head(suit)
head(deman)
head(demand)
scenarios <- aluc(lc=lc, suit=suit, spatial=spatial,demand=as.matrix(demand), elas=as.matrix(elas), traj=as.matrix(traj), nochange.lc=nochange.lc, init.years=5, ncores=detectCores()/2,iter.max=100, writeRaster=FALSE)
source('~/.active-rstudio-document')
scenarios <- aluc(lc=lc, suit=suit, spatial=spatial,demand=as.matrix(demand), elas=as.matrix(elas), traj=as.matrix(traj), nochange.lc=nochange.lc, init.years=5, ncores=detectCores()/2,iter.max=100, writeRaster=FALSE)
demand
demand[1,]
source('~/.active-rstudio-document')
scenarios <- aluc(lc=lc, suit=suit, spatial=spatial,demand=as.matrix(demand), elas=as.matrix(elas), traj=as.matrix(traj), nochange.lc=nochange.lc, init.years=5, ncores=detectCores()/2,iter.max=100, writeRaster=FALSE)
1:length(np)
source('~/.active-rstudio-document')
scenarios <- aluc(lc=lc, suit=suit, spatial=spatial,demand=as.matrix(demand), elas=as.matrix(elas), traj=as.matrix(traj), nochange.lc=nochange.lc, init.years=5, ncores=detectCores()/2,iter.max=100, writeRaster=FALSE)
