log1
nrow(log1)
log2
log2<- c()
log2 <- rbind(log2,log1[nrow(log1),])
#protected areas
tprop_vector[sp.rest_index] <- data_vector[sp.rest_index];
#natural vegetation to pseudo.N code
tprop_vector [is.element(tprop_vector, natural)] <- pseudo.N
#natural vegetation module - reclassify natural vegetation according to transition classes
pseudo.index <- which(is.element(tprop_vector, pseudo.N))
for (i in 1:length(pseudo.index)){
#can before.n be translated to natural
for (a in length(natural):1){
tprop_vector[pseudo.index[i]] <-
ifelse(traj[tprop.previous_vector[pseudo.index[i]], natural[a]] < trans.years_vector[i], natural[a], tprop_vector[pseudo.index[i]])
cat(i)
}}
tprop_vector[nochange_index] <- data_vector[nochange_index]
transition.years_vector <- ifelse(tprop_vector==tprop.previous_vector, trans.years_vector + 1, 1);
# save as raster object
new.data <- lc
new.data <- setValues(new.data, tprop_vector)
plot(new.data)
assign(paste("scenario", epoche, sep=""), new.data)
tprop_previous_vector <- tprop_vector;
print("epoche done")
epoche <- epoche+1
print("EPOCHE:",epoche, sep=" ")
#raster to vector
data_vector <- if (epoche==1) {
getValues(lc)
}else {
tprop_previous_vector # getValues (new.data) # change to "tprop_previous_vector" or "tprop_vector" no need to read raster values, since they are stored already
}
p_vector <-   if(class(suit)=="RasterStack" | class(suit)=="RasterBrick"){
getValues(suit) # if only one stack is specified
}else if (class(suit)=="character"){
getValues(get(suit[epoche])) # in case different stacks for each episode are specified - possibly usefull if  for example new roads are build
}
sp.rest_vector <- if(class(spatial)=="RasterLayer"){
getValues(spatial) # spatial restrictions
}else if (class(spatial)=="character"){
getValues(get(spatial[epoche])) # in case different stacks for each episode are specified - possibly useful if the protected area network will be expanded during the modelling experiment
}
#####
### descriptive variables
#land use classes to be modelled
lu_suit <- as.numeric(gsub("lc","",colnames(p_vector)))   # tolower(colnames(p_vector))
#no change classes
no.change <- as.numeric(gsub("lc","",nochange.lc))
#natural land cover classes (as numeric)
natural <- as.numeric(gsub("lc","",natural.lc))
# same as length (lu_suit) number of suitability layers to be modeled
#lu_suit_l <- ncol(p_vector)
# pixel for all land use/cover classes
lc_pix <- tabulate(data_vector, nbins=max(data_vector))
# total amount of pixels (excl. NAs)
lc_n <- sum(lc_pix)
# unique classes land use/cover classes
lc_unique <- sort(unique(data_vector))
#?	# +1 pseudo natural layer for iteration algorithm
pseudo.N <- max(lu_suit)+1
lu.N <- c(lu_suit,  pseudo.N)
lc_suit.N <- length(lu.N)
#####
# natural vegetation vector
p.natural<- rep(0.5, times=length(data_vector))
# mask NAs from p_vector
if (all(complete.cases(data_vector))==FALSE){ # skip in case no NAs exits
p_vector[is.na(data_vector), ] <- NA
p.natural[is.na(data_vector)]  <- NA
}
#mask no change classes from p_vector
if (length(no.change) > 0 ){
nochange_index <- is.element(data_vector, no.change)
p_vector[nochange_index, ] <- NA
p.natural[nochange_index]  <- NA
}
# mask spatial restrictions from p_vector
if (length(sp.rest_vector) > 0 ){
sp.rest_index <- which(!is.na(sp.rest_vector));
p_vector[sp.rest_index,] <- NA;
p.natural [sp.rest_index] <- NA
}
#####
## adjust demand file
# 1. add natural demand
# 2. adjust for spatial restrictions (based on sp.rest_index)
# 3. combine natural and adjusted demand
nochange.n <- if (length(no.change) > 0 ){
sum (lc_pix[no.change ])
}else {c(0)}
natural.d <- lc_n - nochange.n - sum(demand[epoche,])
#
lc.sp.rest <- tabulate(data_vector[sp.rest_index], nbins=max(lc_unique))
demand.adj <- demand[epoche,] - lc.sp.rest [sort(lu_suit)]
natural.adj <- natural.d - sum(lc.sp.rest[natural])
print(natural.adj)
if (sign(natural.adj)== -1){print("land use cannot be allocated")}
#
demand.new <- as.integer(cbind(demand.adj, natural.adj))
print(demand.new)
#####
# 1. how long is the current land use/cover already there? define for the first epoche. The next are updated during modelling steps
# 2. set previous year land cover vector (copy data vectore) ## neccesary?
if (epoche==1){
trans.years_vector <-  if(class(init.years)=="RasterLayer"){
getValues (init.years)
} else {
rep(init.years, length (data_vector))
}
tprop.previous_vector <- data_vector
}
#####
# transition years (a little complex)
# general:
# transitions which are not allowed are set to NA in the respective suitability layer (target)
# transitions different to 1, referring to transition possible after one iteration (year) are identified
# those identified are checked against the transition years vector. if years < transition years the target suitability is set to NA
# specific steps:
# first edit trajectory matrix
if (length(traj[traj==0 | is.na(traj)] )>0){
# for not allowed changes (100 years more than modelling years)
traj[traj==0 | is.na (traj)] <- nrow(demand)+ 100
}
# conversion restrictions from all land covers to the  land use classes (suitability layer)
# for all unique land cover classes to land use classes
for (i in 1:length(lc_unique)){
# identify classes with restricted trajectories to land use
traj_ind <- which (traj[lc_unique[i],lu_suit] != 1)
# in case no restriction due to trajectories apply
if (length(traj_ind) > 0){
# index classes with restricted trajectories
cat_index <- which(tprop.previous_vector==lc_unique[i])
for (a in 1:length(traj_ind)){
# set p_vector at the specific location for the specific layer  to NA if the amount of years is not reached
p_vector[cat_index, traj_ind[a]]<- ifelse (trans.years_vector[cat_index] < traj[lc_unique[i], lu_suit[a]], NA, p_vector[cat_index, traj_ind[a]])
cat(i)
}}
}
# conversion restrictions from all land covers to natural vegetation class
for (i in 1:length(lc_unique)){
traj_ind <- which(is.element (1 ,  traj[lc_unique[i],natural])==FALSE) # identify which trajectories are unequal 1 (are not allowed after one year)
if (length(traj_ind) > 0){
cat_index <- which(tprop.previous_vector==lc_unique[i])
p.natural[cat_index] <- ifelse (trans.years_vector[cat_index] < min(traj[lc_unique[i], natural]), NA, p.natural[cat_index])
cat(i)
#print(trans.years_vector[cat_index] < min(traj[lc_unique[i], natural]))
}}
########
# p_vector normalization skipped
########
# add ELAS
for (i in 1:length(lu_suit)) {
elas_index <- which(data_vector==lu_suit[i])
p_vector[elas_index,i] <- p_vector[elas_index, i] + as.numeric(elas[lu_suit[i]])
}
# add ELAS on natural vegetation layer
for (i in 1: length (natural)){
elas_index <- which(data_vector== natural[i])
p.natural[elas_index] <- p.natural[elas_index] + as.numeric(elas[natural[i]])
}
#########
# combine p vector with natural vegetation vector
p_vector.N <- cbind( p_vector, p.natural)
allocation <- alocation.module (p_vector.N,lu.N ,demand.new, stop.crit, iter.max, ncores, print.plot, print.log)
tprop_vector <- allocation[[1]]
log1 <- rbind (log1, allocation[[2]])
log2 <- rbind(log2,log1[nrow(log1),])
log1
log2
tprop_vector[sp.rest_index] <- data_vector[sp.rest_index];
#natural vegetation to pseudo.N code
tprop_vector [is.element(tprop_vector, natural)] <- pseudo.N
#natural vegetation module - reclassify natural vegetation according to transition classes
pseudo.index <- which(is.element(tprop_vector, pseudo.N))
for (i in 1:length(pseudo.index)){
#can before.n be translated to natural
for (a in length(natural):1){
tprop_vector[pseudo.index[i]] <-
ifelse(traj[tprop.previous_vector[pseudo.index[i]], natural[a]] < trans.years_vector[i], natural[a], tprop_vector[pseudo.index[i]])
#cat(i)
}}
#stable classes
#nochange_index <- match(nochange.lc, data_vector)
tprop_vector[nochange_index] <- data_vector[nochange_index]
## compare this allocation for transistion years, inc if changed, reset to 1 if change
transition.years_vector <- ifelse(tprop_vector==tprop.previous_vector, trans.years_vector + 1, 1);
# save as raster object
new.data <- lc
new.data <- setValues(new.data, tprop_vector)
plot(new.data)
source('~/.active-rstudio-document', echo=TRUE)
lc<- raster("tc08_aggregated.tif" )
suit<- stack("suitability_stack.tif"); names(suit)<- c("lc1","lc2","lc3","lc4","lc7","lc8")
suit_lu <- subset(suit, subset=c("lc3", "lc4", "lc7"))
spatial<- raster("PAall_aggregated.tif")
#load csv
demand<- read.csv("demand_aggregated.csv", row.names=1)
demand_lu <- demand[,c(3,4,7)] # land use demand pasture, crop, urban
names(demand_lu)<- c("lc3", "lc4", "lc7")
nochange.lc <- c("lc5","lc6","lc8") # müssen ausmaskiert werden und später wieder eingesetzt
natural.lc <- c("lc1","lc2")
elas<- read.csv("elas.csv",row.names=1)
traj <- read.csv("trajectories.csv",row.names=1)
init.years=5
ncores=detectCores()/2
suit  <- subset (suit_lu, subset=c(3,2,1))
demand <- demand_lu
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
scenario <- aluc(lc=lc, suit=suit, natural=c(1,2), nochange.lc=c(5,6,8), spatial=spatial, demand=demand, elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
source('~/GitHub/tmp/function_aluc_23022015.r', echo=TRUE)
source('~/GitHub/tmp/function_aluc_allocation_module_23022015.r', echo=TRUE)
source('~/GitHub/tmp/function_aluc_23022015.r', echo=TRUE)
scenario <- aluc(lc=lc, suit=suit, natural=c(1,2), nochange.lc=c(5,6,8), spatial=spatial, demand=demand, elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
scenario.raster <- scenarios[[1]]
scenario.raster <- scenario[[1]]
plot(scenario.raster,y=1:16, col=c("darkgreen", "lightgreen", "orange", "yellow","white","darkblue" , "red", "grey"))
plot(scenario.raster,y=c(1,22), col=c("darkgreen", "lightgreen", "orange", "yellow","white","darkblue" , "red", "grey"))
Which(lc==7)== Which(subset(scenario.raster, subset=22)==7)
Which(lc==7)
Which(lc==7)
lc<- raster("tc08_aggregated.tif" )
Which(lc==7)
which(lc==7)
?which
Which
?Which
which(lc==7, cells=TRUE)
Which(lc==7, cells=TRUE)
Which(subset(scenario.raster, subset=22)==7, cells=TRUE)
is.element (Which(lc==7, cells=TRUE) ,Which(subset(scenario.raster, subset=22)==7, cells=TRUE)
)
is.element (Which(lc==5, cells=TRUE) ,Which(subset(scenario.raster, subset=22)==5, cells=TRUE)
)
is.element (Which(lc==6, cells=TRUE) ,Which(subset(scenario.raster, subset=22)==6, cells=TRUE))
is.element (Which(lc==8, cells=TRUE) ,Which(subset(scenario.raster, subset=22)==8, cells=TRUE))
is.element (Which(lc==7, cells=TRUE) ,Which(subset(scenario.raster, subset=22)==7, cells=TRUE))
length(Which(lc==7, cells=TRUE))
length(Which(subset(scenario.raster, subset=22)==7, cells=TRUE))
demand
is.element (Which(lc==7, cells=TRUE) ,Which(subset(scenario.raster, subset=22)==7, cells=TRUE))
source('~/.active-rstudio-document', echo=TRUE)
source('~/GitHub/tmp/function_aluc_allocation_module_23022015.r', echo=TRUE)
source('~/GitHub/tmp/function_aluc_23022015.r', echo=TRUE)
demand[,c(1:10)]
demand[c(1:10),]
scenario <- aluc(lc=lc, suit=suit, natural=c(1,2), nochange.lc=c(5,6,8), spatial=spatial, demand=demand[c(1:10),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
source('~/GitHub/tmp/function_aluc_allocation_module_23022015.r', echo=TRUE)
source('~/GitHub/tmp/function_aluc_23022015.r', echo=TRUE)
scenario <- aluc(lc=lc, suit=suit, natural=c(1,2), nochange.lc=c(5,6,8), spatial=spatial, demand=demand[c(1:10),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
plot(0,0,xlim = c(2,iter.max),ylim = c(-1.5,1.5),ylab="iter", xlab="iteration", type = "n")
iter.max=100
plot(0,0,xlim = c(2,iter.max),ylim = c(-1.5,1.5),ylab="iter", xlab="iteration", type = "n")
legend("topright", legend=paste("LC",lu.N, sep=""), col=terrain.colors(length(lu.N)), pch=15)
source('~/GitHub/tmp/function_aluc_allocation_module_23022015.r', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
scenario <- aluc(lc=lc, suit=suit, natural=c(1,2), nochange.lc=c(5,6,8), spatial=spatial, demand=demand[c(1:10),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
logfile1 <- scenarios[[2]]
View(logfile1)
logfile1 <- scenario[[2]]
View(logfile1)
View(logfile1[,c(10:14)])
logfile1[,c(10:14)])
logfile1[,c(10:14)]
logfile1[c(10:14),]
logfile1[,c(10:13)]
which(logfile1[,c(10:13)]<1)
which(logfile1[,c(10:13)]>1)
which(logfile1[1,c(10:13)]>1)
which(logfile1[2,c(10:13)]>1)
which(logfile1[3,c(10:13)]>1)
which(logfile1[4,c(10:13)]>1)
logfile1[1,c(10:13)]
which(logfile1[,10]>1)
which(logfile1[,12]>1)
which(logfile1[,11]>1)
which(logfile1[,13]>1)
which(logfile1[,14]>1)
logfile1[,10]
logfile1[1,10]
as.numeric(logfile1[,10])
which(as.numeric(logfile1[,10])<-1)
which(as.numeric(logfile1[,10])< -1)
which(as.numeric(logfile1[,11])< -1)
which(as.numeric(logfile1[,12])< -1)
which(as.numeric(logfile1[,13])< -1)
lu.N
lu.N<- c(3,4,7,8)
lu.N[-length(lu.N)]
paste ("LC", c (lu.N[-length(lu.N)],"N"))
source('~/GitHub/tmp/function_aluc_allocation_module_23022015.r', echo=TRUE)
source('~/GitHub/tmp/function_aluc_23022015.r')
setwd("C:/Users/geo_flgo/Documents/GitHub/alucR/example_data/small")
#load packages
library(rgdal)
library(sp)
library(raster)
library(parallel)
#load raster
lc<- raster("tc08_aggregated.tif" )
suit<- stack("suitability_stack.tif"); names(suit)<- c("lc1","lc2","lc3","lc4","lc7","lc8")
suit_lu <- subset(suit, subset=c("lc3", "lc4", "lc7"))
spatial<- raster("PAall_aggregated.tif")
#load csv
demand<- read.csv("demand_aggregated.csv", row.names=1)
demand_lu <- demand[,c(3,4,7)] # land use demand pasture, crop, urban
names(demand_lu)<- c("lc3", "lc4", "lc7")
nochange.lc <- c("lc5","lc6","lc8") # müssen ausmaskiert werden und später wieder eingesetzt
natural.lc <- c("lc1","lc2")
elas<- read.csv("elas.csv",row.names=1)
traj <- read.csv("trajectories.csv",row.names=1)
init.years=5
ncores=detectCores()/2
suit  <- subset (suit_lu, subset=c(3,2,1))
demand <- demand_lu
# sceanrios
debug(aluc)
scenario <- aluc(lc=lc, suit=suit, natural=c(1,2), nochange.lc=c(5,6,8), spatial=spatial, demand=demand[c(1:10),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
c
source('~/.active-rstudio-document')
source('~/GitHub/tmp/function_aluc_allocation_module_23022015.r')
scenario <- aluc(lc=lc, suit=suit, natural=c(1,2), nochange.lc=c(5,6,8), spatial=spatial, demand=demand[c(1:10),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
?palette
colors()
demo("colors")
source('~/.active-rstudio-document')
scenario <- aluc(lc=lc, suit=suit, natural=c(1,2), nochange.lc=c(5,6,8), spatial=spatial, demand=demand[c(1:10),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
source('~/GitHub/tmp/function_aluc_23022015.r')
source('~/.active-rstudio-document')
source('~/GitHub/tmp/function_aluc_23022015.r')
setwd("C:/Users/geo_flgo/Documents/GitHub/alucR/example_data/small")
#load packages
library(rgdal)
library(sp)
library(raster)
library(parallel)
#load raster
lc<- raster("tc08_aggregated.tif" )
suit<- stack("suitability_stack.tif"); names(suit)<- c("lc1","lc2","lc3","lc4","lc7","lc8")
suit_lu <- subset(suit, subset=c("lc3", "lc4", "lc7"))
spatial<- raster("PAall_aggregated.tif")
#load csv
demand<- read.csv("demand_aggregated.csv", row.names=1)
demand_lu <- demand[,c(3,4,7)] # land use demand pasture, crop, urban
names(demand_lu)<- c("lc3", "lc4", "lc7")
nochange.lc <- c("lc5","lc6","lc8") # müssen ausmaskiert werden und später wieder eingesetzt
natural.lc <- c("lc1","lc2")
elas<- read.csv("elas.csv",row.names=1)
traj <- read.csv("trajectories.csv",row.names=1)
init.years=5
ncores=detectCores()/2
suit  <- subset (suit_lu, subset=c(3,2,1))
demand <- demand_lu
# sceanrios
debug(aluc)
scenario <- aluc(lc=lc, suit=suit, natural=c(1,2), nochange.lc=c(5,6,8), spatial=spatial, demand=demand[c(1:10),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
?sign
print("land use cannot be allocated")
source('~/.active-rstudio-document')
scenario <- aluc(lc=lc, suit=suit, natural=c(1,2), nochange.lc=c(5,6,8), spatial=spatial, demand=demand[c(1:10),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
source('~/.active-rstudio-document')
scenario <- aluc(lc=lc, suit=suit, natural=c(1,2), nochange.lc=c(5,6,8), spatial=spatial, demand=demand[c(1:10),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
demand[2,]
source('~/GitHub/tmp/function_aluc_23022015.r')
scenario <- aluc(lc=lc, suit=suit, natural=c(1,2), nochange.lc=c(5,6,8), spatial=spatial, demand=demand[c(1:10),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
source('~/.active-rstudio-document')
scenario <- aluc(lc=lc, suit=suit, natural=c(1,2), nochange.lc=c(5,6,8), spatial=spatial, demand=demand[c(1:10),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
source('~/.active-rstudio-document')
scenario <- aluc(lc=lc, suit=suit, natural=c(1,2), nochange.lc=c(5,6,8), spatial=spatial, demand=demand[c(1:10),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
scenario <- aluc(lc=lc, suit=suit, natural=c("lc1","lc2"), nochange.lc=c("lc5","lc6","lc8"), spatial=spatial, demand=demand[c(1:10),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
source('~/.active-rstudio-document')
scenario <- aluc(lc=lc, suit=suit, natural=c("lc1","lc2"), nochange.lc=c("lc5","lc6","lc8"), spatial=spatial, demand=demand[c(1:10),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
plot(lc)
source('~/.active-rstudio-document')
scenario <- aluc(lc=lc, suit=suit, natural=c("lc1","lc2"), nochange.lc=c("lc5","lc6","lc8"), spatial=spatial, demand=demand[c(1:10),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
source('~/GitHub/tmp/function_aluc_23022015.r')
scenario <- aluc(lc=lc, suit=suit, natural=c("lc1","lc2"), nochange.lc=c("lc5","lc6","lc8"), spatial=spatial, demand=demand[c(1:10),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
source('~/GitHub/tmp/function_aluc_23022015.r')
scenario <- aluc(lc=lc, suit=suit, natural=c("lc1","lc2"), nochange.lc=c("lc5","lc6","lc8"), spatial=spatial, demand=demand[c(1:10),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
setwd("C:/Users/geo_flgo/Documents/GitHub/alucR/example_data/small")
#load packages
library(rgdal)
library(sp)
library(raster)
library(parallel)
#load raster
lc<- raster("tc08_aggregated.tif" )
suit<- stack("suitability_stack.tif"); names(suit)<- c("lc1","lc2","lc3","lc4","lc7","lc8")
suit_lu <- subset(suit, subset=c("lc3", "lc4", "lc7"))
spatial<- raster("PAall_aggregated.tif")
#load csv
demand<- read.csv("demand_aggregated.csv", row.names=1)
demand_lu <- demand[,c(3,4,7)] # land use demand pasture, crop, urban
names(demand_lu)<- c("lc3", "lc4", "lc7")
nochange.lc <- c("lc5","lc6","lc8") # müssen ausmaskiert werden und später wieder eingesetzt
natural.lc <- c("lc1","lc2")
elas<- read.csv("elas.csv",row.names=1)
traj <- read.csv("trajectories.csv",row.names=1)
init.years=5
ncores=detectCores()/2
suit  <- subset (suit_lu, subset=c(3,2,1))
demand <- demand_lu
writeRaster(suit, "lu_suitability_stack.tif")
write.csv (demand, "lu_demand_aggregated.csv")
#author: florian.gollnow@geo.hu-berlin.de
# Landuse/cover classes
# LC1 Forest
# LC2 Secondary Vegetation
# LC3 Pasture
# LC4 Cropland
# LC5 Clouds
# LC6 Water
# LC7 Urban
# LC8 Other
# The land use/cover data is a reclassified TerraClass product of INPE http://www.inpe.br/cra/projetos_pesquisas/terraclass2010.php
#example script:
#set workingdirectory
setwd("C:/Users/geo_flgo/Documents/GitHub/alucR/example_data/small")
#load packages
library(rgdal)
library(sp)
library(raster)
library(parallel)
#load raster
lc<- raster("tc08_aggregated.tif" )
suit<- stack("lu_suitability_stack.tif"); names(suit)<- c("lc7","lc4","lc3")
spatial<- raster("PAall_aggregated.tif")
#load csv
demand<- read.csv("lu_demand_aggregated.csv", row.names=1)
names(demand_lu)<- c("lc3", "lc4", "lc7")
nochange.lc <- c("lc5","lc6","lc8") # müssen ausmaskiert werden und später wieder eingesetzt
natural.lc <- c("lc1","lc2")
elas<- read.csv("elas.csv",row.names=1)
traj <- read.csv("trajectories.csv",row.names=1)
init.years=5
ncores=detectCores()/2
names(demand)<- c("lc3", "lc4", "lc7")
demand
source('~/GitHub/tmp/function_aluc_23022015.r')
scenario <- aluc(lc=lc, suit=suit, natural=c("lc1","lc2"), nochange.lc=c("lc5","lc6","lc8"), spatial=spatial, demand=demand, elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
setwd("C:/Users/geo_flgo/Documents/GitHub/alucR/")
dir
dir()
setwd("C:/Users/geo_flgo/Documents/GitHub/alucR/example_data")
dir()
setwd("C:/Users/geo_flgo/Documents/GitHub/alucR/example_data/big")
dir()
lc<- raster("tc08.tif" )
suit<- stack("suitability_stack.tif"); names(suit)<- c("lc1","lc2","lc3","lc4","lc7","lc8")
suit <- stack("urban_buffer.tif", "pcropES.tif", ,"ppastureES.tif")
names(suit)<- c("lc7", "lc4", "lc3") #naming scheme
suit <- stack("urban_buffer.tif", "pcropES.tif", "ppastureES.tif")
names(suit)<- c("lc7", "lc4", "lc3") #naming scheme
spatial <- raster("pa_all.tif")
demand<- read.csv("demand.csv", header=F)
demand
demand_lu <- demand[,c(3,4,7)] # land use demand pasture, crop, urban
names(demand_lu)<- c("lc3", "lc4", "lc7")
write.csv(demand_lu, "lu_demand.csv")
demand<- read.csv("lu_demand.csv", header=F)
demand
demand<- read.csv("lu_demand.csv", header=T)
demand
demand<- read.csv("lu_demand.csv", header=T, row.names=1)
demand
library(rgdal)
library(sp)
library(raster)
library(parallel)
# setwd("q:/florian/data/studyclue/r_model_2015")
setwd("C:/Users/geo_flgo/Documents/GitHub/alucR/example_data/big")
# raster
lc <- raster("tc08.tif")
suit <- stack("urban_buffer.tif", "pcropES.tif", "ppastureES.tif")
names(suit)<- c("lc7", "lc4", "lc3") #naming scheme
spatial <- raster("pa_all.tif")
# tables & vectors
demand<- read.csv("lu_demand.csv", header=T, row.names=1)
#names(demand)<- c("lc3", "lc4", "lc7")
elas <- read.csv("elasticities.csv", header=F)
trajectories <-  read.csv("trajectories.csv", header=F)
nochange.lc <- c("lc5","lc6","lc8") # müssen ausmaskiert werden und später wieder eingesetzt
natural.lc <- c("lc1","lc2")
init.years=5
ncores=detectCores()/2
demand[c(1:5),]
scenario <- aluc(lc=lc, suit=suit, natural=c("lc1","lc2"), nochange.lc=c("lc5","lc6","lc8"), spatial=spatial, demand=demand[c(1:5),], elas=as.matrix(elas), traj=as.matrix(traj),
init.years= 5,  stop.crit=c(0.0003 , 1, 10), iter.max=100, ncores=detectCores()/2, print.log=TRUE, print.plot=TRUE, writeRaster=FALSE)
