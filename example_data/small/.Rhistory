??moreinI
??MorainsI
install.packages("devtools")
library(devtools)
install_github("simonmoulds/r_lulccR", subdir = "lulccR")
library(lulccR)
library(devtools)
install_github("simonmoulds/r_lulccR", subdir = "lulccR")
library(lulccR)
library(devtools)
library(devtools)
find_rtools()
find_rtools()
library(devtools)
install_github("simonmoulds/r_lulccR", subdir = "lulccR")
4723,
sum(c(4723,1158,839,224,282)
)
?sampel
?sampel
?sample
sample(1,10)
sample(1:100,1)
sample(50:100,1)
random
?runif
10000*10000
1000*1000
setwd("C:/Users/geo_flgo/Documents/GitHub/alucR/example_data/small")
#load packages
library(rgdal)
library(sp)
library(raster)
library(parallel)
#load raster
lc<- raster("tc08_aggregated.tif" )
suit<- stack("suitability_stack.tif"); names(suit)<- c("lc1","lc2","lc3","lc4","lc7","lc8")
spatial<- raster("PAall_aggregated.tif")
demand<- read.csv("demand_aggregated.csv", row.names=1)
elas<- read.csv("elas.csv",row.names=1)
traj <- read.csv("trajectories.csv",row.names=1)
View(demand)
data_vector <- if (epoche==1) {
getValues(lc)
}else {
getValues (new.data)
}
p_vector <-   if(class(suit)=="RasterStack" | class(suit)=="RasterBrick"){
getValues(suit)
}else if (class(suit)=="character"){
getValues(stack(get(suit)[epoche]))
}
sp.rest_vector <- if(class(spatial)=="RasterLayer"){
getValues(spatial)
}else if (class(spatial)=="character"){
getValues(stack(get(spatial)[epoche]))
}
#####
print ("raster to vector conversion done")
#####
epoche=1
data_vector <- if (epoche==1) {
getValues(lc)
}else {
getValues (new.data)
}
p_vector <-   if(class(suit)=="RasterStack" | class(suit)=="RasterBrick"){
getValues(suit)
}else if (class(suit)=="character"){
getValues(stack(get(suit)[epoche]))
}
sp.rest_vector <- if(class(spatial)=="RasterLayer"){
getValues(spatial)
}else if (class(spatial)=="character"){
getValues(stack(get(spatial)[epoche]))
}
tabular(lc)
tabulate(lc)
tabulate(lc, bin=layer)
lc_cat <- as.numeric(gsub("lc","",colnames(p_vector)))   # tolower(colnames(p_vector))
layer <- ncol(p_vector)
tabulate(lc, bin=lc_cat)
table
table(lc)
tabulate(data_vector, bin=lc_cat)
tabel(data_vector)
table(data_vector)
str(table(data_vector))
demand
demand_lu <- demand[,c(3,4,7)] # land use demand pasture, crop, urban
head(demand_lu)
names(demand_lu)<- c("lc3", "lc4", "lc7")
head(demand_lu)
if (all(complete.cases(data_vector))==FALSE){
p_vector [is.na(data_vector), ] <- NA
}
if (epoche==1){
trans.years_vector <- rep(init.years, length (data_vector))
tprop.previous_vector <- data_vector
}
init.years=5
if (epoche==1){
trans.years_vector <- rep(init.years, length (data_vector))
tprop.previous_vector <- data_vector
}
print ("start trajectories")
for (i in 1:layer){
traj_ind <- which (traj[lc_cat[i],lc_cat] != 1) # identify classes with restricted trajectories
cat_index <- which(tprop.previous_vector==lc_cat[i]) # index classes
for (a in 1:length(traj_ind)){
p_vector[cat_index, traj_ind[a]]<- ifelse (trans.years_vector[cat_index] < traj[traj_ind[a], lc_cat[i]], NA, p_vector[cat_index, traj_ind[a]])
cat(i)
}
}
if (class(sp.rest_vector)!="NULL"){
sp.rest_index <- which(!is.na(sp.rest_vector));
p_vector[sp.rest_index,] <- NA;
}
as.numeric(gsub("lc", "", nochange.lc))
as.numeric(gsub("lc", "", no.changelc))
nochange.lc <- c("lc5","lc6","lc8") # müssen ausmaskiert werden und später wieder eingesetzt
as.numeric(gsub("lc", "", nochange.lc))
tabulate(data_vector[sp.rest_index], nbins=max(lc_cat))
table(data_vector[sp.rest_index])
suit_lu <- subset(suit, subset=c("lc3", "lc4", "lc7"))
head(suit_lu)
natural.lc <- c("lc1","lc2")
p_vector <-   if(class(suit)=="RasterStack" | class(suit)=="RasterBrick"){
getValues(suit_lu)
}else if (class(suit)=="character"){
getValues(stack(get(suit)[epoche]))
}
lc_cat <- as.numeric(gsub("lc","",colnames(p_vector)))   # tolower(colnames(p_vector))
layer <- ncol(p_vector)
if (all(complete.cases(data_vector))==FALSE){
p_vector [is.na(data_vector), ] <- NA
}
if (epoche==1){
trans.years_vector <- rep(init.years, length (data_vector))
tprop.previous_vector <- data_vector
}
for (i in 1:layer){
traj_ind <- which (traj[lc_cat[i],lc_cat] != 1) # identify classes with restricted trajectories
cat_index <- which(tprop.previous_vector==lc_cat[i]) # index classes
for (a in 1:length(traj_ind)){
p_vector[cat_index, traj_ind[a]]<- ifelse (trans.years_vector[cat_index] < traj[traj_ind[a], lc_cat[i]], NA, p_vector[cat_index, traj_ind[a]])
cat(i)
}
}
layer
lc_cat
traj_ind
is.na(traj_ind)
complete.cases(traj_ind)
which (traj[lc_cat[i],lc_cat] != 1
which (traj[lc_cat[i],lc_cat] != 1)
which (traj[lc_cat[i],lc_cat] != 1, arr.ind=TRUE)
i
is.null(traj_ind)
traj_ind
str(traj_ind)
length(traj_ind)
for (i in 1:layer){
traj_ind <- which (traj[lc_cat[i],lc_cat] != 1) # identify classes with restricted trajectories
cat_index <- which(tprop.previous_vector==lc_cat[i]) # index classes
if (length(traj_ind)>0){
for (a in 1:length(traj_ind)){
p_vector[cat_index, traj_ind[a]]<- ifelse (trans.years_vector[cat_index] < traj[traj_ind[a], lc_cat[i]], NA, p_vector[cat_index, traj_ind[a]])
cat(i)
}}
}
lc_cat
lc_cat
natural.lc
